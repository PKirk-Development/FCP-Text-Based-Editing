"""
Export engine: FFmpeg video trimming and FCPXML generation.

Two export paths
----------------
1. FFmpeg   → trimmed, re-encoded or stream-copied .mp4 / .mov
2. FCPXML   → Final Cut Pro XML that FCP imports directly (round-trip)

Both use the same keep_ranges list produced by timeline.get_keep_ranges().

FCPXML timing uses a 44100 Hz timescale (LCM-friendly audio sample rate) which
gives ~22 µs resolution — accurate enough for any buffer ≥ 1 ms.
"""

from __future__ import annotations

import subprocess
from pathlib import Path
from typing import Callable, Optional
from xml.etree import ElementTree as ET

from .fcpxml_parser import to_fcpxml_time, parse_time
from .models import Project, Silence, TextSegment
from .timeline import get_keep_ranges

# FCPXML timescale: 44100 = audio sample-rate, great common denominator
FCPXML_TIMESCALE = 44100


# ── FFmpeg export ─────────────────────────────────────────────────────────────

def export_video(
    project: Project,
    output_path: str,
    stream_copy: bool = False,
    progress_cb: Optional[Callable[[str], None]] = None,
) -> None:
    """
    Export the edited video to *output_path* using FFmpeg.

    Parameters
    ----------
    project      : The project (provides video_path, segments, deleted, etc.)
    output_path  : Destination file path (.mp4, .mov, …)
    stream_copy  : If True, use stream copy (fast, lossless, but may have
                   seek/cut inaccuracies near non-keyframes).
                   If False (default), re-encode at high quality.
    progress_cb  : Called with status strings during export.
    """
    keep = get_keep_ranges(
        project.segments,
        set(project.deleted),
        project.silence_settings.buffer,
        project.video_duration,
    )

    if not keep:
        raise ValueError("Nothing to export: all segments are deleted.")

    if progress_cb:
        progress_cb(f"Building FFmpeg command for {len(keep)} segment(s)…")

    if len(keep) == 1 and keep[0] == (0.0, project.video_duration):
        # No edits at all — just copy
        cmd = [
            "ffmpeg", "-y",
            "-i", project.video_path,
            "-c", "copy",
            output_path,
        ]
    else:
        cmd = _build_ffmpeg_concat_cmd(
            project.video_path,
            keep,
            output_path,
            stream_copy=stream_copy,
        )

    if progress_cb:
        progress_cb("Running FFmpeg…")

    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode != 0:
        raise RuntimeError(
            f"FFmpeg export failed:\n{result.stderr[-3000:]}"
        )

    if progress_cb:
        progress_cb(f"Export complete → {output_path}")


def _build_ffmpeg_concat_cmd(
    video_path: str,
    keep_ranges: list[tuple[float, float]],
    output_path: str,
    stream_copy: bool = False,
) -> list[str]:
    """Build an FFmpeg command using filter_complex trim+concat."""
    n = len(keep_ranges)

    filter_parts: list[str] = []
    v_labels: list[str] = []
    a_labels: list[str] = []

    for i, (start, end) in enumerate(keep_ranges):
        dur = end - start
        filter_parts.append(
            f"[0:v]trim=start={start:.4f}:duration={dur:.4f},"
            f"setpts=PTS-STARTPTS[v{i}]"
        )
        filter_parts.append(
            f"[0:a]atrim=start={start:.4f}:duration={dur:.4f},"
            f"asetpts=PTS-STARTPTS[a{i}]"
        )
        v_labels.append(f"[v{i}]")
        a_labels.append(f"[a{i}]")

    concat_input = "".join(v_labels) + "".join(a_labels)
    filter_parts.append(
        f"{concat_input}concat=n={n}:v=1:a=1[outv][outa]"
    )

    filter_complex = ";".join(filter_parts)

    if stream_copy:
        video_codec = ["-c:v", "copy"]
        audio_codec = ["-c:a", "copy"]
    else:
        video_codec = ["-c:v", "libx264", "-preset", "fast", "-crf", "18"]
        audio_codec = ["-c:a", "aac", "-b:a", "192k"]

    cmd = (
        ["ffmpeg", "-y", "-i", video_path]
        + ["-filter_complex", filter_complex]
        + ["-map", "[outv]", "-map", "[outa]"]
        + video_codec
        + audio_codec
        + [output_path]
    )
    return cmd


def generate_ffmpeg_script(
    project: Project,
    output_path: str,
    script_path: str,
) -> None:
    """
    Write a standalone shell script that performs the FFmpeg export.
    Useful when the user wants to inspect or run the command manually.
    """
    keep = get_keep_ranges(
        project.segments,
        set(project.deleted),
        project.silence_settings.buffer,
        project.video_duration,
    )
    cmd = _build_ffmpeg_concat_cmd(project.video_path, keep, output_path)
    with open(script_path, "w") as fh:
        fh.write("#!/bin/bash\n")
        fh.write("# Generated by FCP Text-Based Editor\n")
        fh.write("# Keep ranges:\n")
        for i, (s, e) in enumerate(keep):
            fh.write(f"#   [{i}] {s:.4f} – {e:.4f} s  ({e-s:.4f} s)\n")
        fh.write("\n")
        fh.write(" \\\n  ".join(cmd) + "\n")
    Path(script_path).chmod(0o755)


# ── EDL export ────────────────────────────────────────────────────────────────

def export_edl(project: Project, output_path: str, title: str = "Edited") -> None:
    """
    Write a basic CMX 3600 EDL.  Useful for import into Premiere Pro, DaVinci,
    Avid, etc.

    Note: EDL uses drop-frame or non-drop-frame timecode.  We use NDF here.
    """
    keep = get_keep_ranges(
        project.segments,
        set(project.deleted),
        project.silence_settings.buffer,
        project.video_duration,
    )

    fps = project.video_fps
    lines = [f"TITLE: {title}", "FCM: NON-DROP FRAME", ""]

    record_tc = 0.0  # running record (output) time

    for i, (src_start, src_end) in enumerate(keep, start=1):
        dur = src_end - src_start

        rec_in  = _sec_to_tc(record_tc,       fps)
        rec_out = _sec_to_tc(record_tc + dur,  fps)
        src_in  = _sec_to_tc(src_start, fps)
        src_out = _sec_to_tc(src_end,   fps)

        lines.append(f"{i:03d}  AX       V     C        {src_in} {src_out} {rec_in} {rec_out}")
        record_tc += dur

    with open(output_path, "w") as fh:
        fh.write("\n".join(lines) + "\n")


def _sec_to_tc(seconds: float, fps: float) -> str:
    """Convert seconds to HH:MM:SS:FF timecode string (NDF)."""
    fps_int  = round(fps)
    total_f  = int(seconds * fps)
    frames   = total_f % fps_int
    total_s  = total_f // fps_int
    secs     = total_s % 60
    total_m  = total_s // 60
    mins     = total_m % 60
    hours    = total_m // 60
    return f"{hours:02d}:{mins:02d}:{secs:02d}:{frames:02d}"


# ── FCPXML export ─────────────────────────────────────────────────────────────

def export_fcpxml(
    project: Project,
    output_path: str,
    progress_cb: Optional[Callable[[str], None]] = None,
) -> None:
    """
    Write a new FCPXML that represents the edited timeline.

    The source asset is referenced as-is (no re-encode), and the spine is
    populated with <clip> elements whose start/duration correspond to the
    keep_ranges.  FCP reads this as a new project containing only the kept
    segments, concatenated at the output offset.

    This is a true lossless round-trip: FCP re-reads the original media
    with the new in/out points.
    """
    keep = get_keep_ranges(
        project.segments,
        set(project.deleted),
        project.silence_settings.buffer,
        project.video_duration,
    )

    if not keep:
        raise ValueError("Nothing to export: all segments are deleted.")

    if progress_cb:
        progress_cb("Generating FCPXML…")

    version   = project.fcpxml_version
    asset_id  = project.fcpxml_asset_id
    format_id = project.fcpxml_format_id

    # Total output duration
    total_out = sum(e - s for s, e in keep)

    # ── Root ─────────────────────────────────────────────────────────────────
    ET.register_namespace("", "")
    root = ET.Element("fcpxml", version=version)

    # ── Resources ─────────────────────────────────────────────────────────────
    resources = ET.SubElement(root, "resources")

    fps_num, fps_den = _fps_to_rational(project.video_fps)
    frame_dur = f"{fps_den}/{fps_num}s"

    ET.SubElement(
        resources, "format",
        id           = format_id,
        name         = f"FFVideoFormat{project.video_height}p{int(round(project.video_fps))}",
        frameDuration= frame_dur,
        fieldOrder   = "progressive",
        width        = str(project.video_width),
        height       = str(project.video_height),
        colorSpace   = "1-1-1 (Rec. 709)",
    )

    asset_src = Path(project.video_path).as_uri()
    asset = ET.SubElement(
        resources, "asset",
        id         = asset_id,
        name       = Path(project.video_path).stem,
        start      = "0s",
        duration   = to_fcpxml_time(project.video_duration, FCPXML_TIMESCALE),
        hasVideo   = "1",
        hasAudio   = "1",
        audioSources  = "1",
        audioChannels = "2",
        audioRate     = "48000",
    )
    ET.SubElement(asset, "media-rep",
        kind = "original-media",
        src  = asset_src,
    )

    # ── Library / event / project / sequence / spine ──────────────────────────
    library  = ET.SubElement(root, "library")
    event    = ET.SubElement(library, "event",   name="Edited")
    proj     = ET.SubElement(event,   "project", name="Edited Project")
    sequence = ET.SubElement(
        proj, "sequence",
        duration    = to_fcpxml_time(total_out, FCPXML_TIMESCALE),
        format      = format_id,
        tcStart     = "0s",
        tcFormat    = "NDF",
        audioLayout = "stereo",
        audioRate   = "48k",
    )
    spine = ET.SubElement(sequence, "spine")

    # ── Clip elements ──────────────────────────────────────────────────────────
    record_offset = 0.0
    for src_start, src_end in keep:
        dur = src_end - src_start
        ET.SubElement(
            spine, "clip",
            name     = Path(project.video_path).stem,
            ref      = asset_id,
            lane     = "0",
            offset   = to_fcpxml_time(record_offset, FCPXML_TIMESCALE),
            start    = to_fcpxml_time(src_start,     FCPXML_TIMESCALE),
            duration = to_fcpxml_time(dur,            FCPXML_TIMESCALE),
            format   = format_id,
        )
        record_offset += dur

    # ── Write ──────────────────────────────────────────────────────────────────
    tree = ET.ElementTree(root)
    ET.indent(tree, space="  ")

    with open(output_path, "wb") as fh:
        fh.write(b'<?xml version="1.0" encoding="UTF-8"?>\n')
        fh.write(b'<!DOCTYPE fcpxml>\n')
        tree.write(fh, encoding="unicode", xml_declaration=False)

    if progress_cb:
        progress_cb(f"FCPXML saved → {output_path}")


def _fps_to_rational(fps: float) -> tuple[int, int]:
    """
    Convert a float frame rate to an integer numerator/denominator pair.
    Common values: 24→(24,1), 25→(25,1), 29.97→(30000,1001), 30→(30,1),
    59.94→(60000,1001), 60→(60,1).
    """
    common = {
        23.976:  (24000, 1001),
        23.98:   (24000, 1001),
        24.0:    (24,    1),
        25.0:    (25,    1),
        29.97:   (30000, 1001),
        30.0:    (30,    1),
        47.952:  (48000, 1001),
        48.0:    (48,    1),
        59.94:   (60000, 1001),
        60.0:    (60,    1),
        119.88:  (120000, 1001),
        120.0:   (120,    1),
    }
    rounded = round(fps, 3)
    if rounded in common:
        return common[rounded]
    # Fall back: use fps * 1000 / 1000
    num = round(fps * 1000)
    return (num, 1000)
